#!/bin/bash
#
# Copyright (C) 2019 Michael Picht
#
# This file is part of crema (Custom Repository Management).
#
# crema is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# crema is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with crema. If not, see <http://www.gnu.org/licenses/>.
#
# This script is based on the work of Michael Daffin on managing
# Arch Linux install. See: https://github.com/mdaffin/arch-pkgs

set -uo pipefail
set -o nounset
trap 's=$?; echo "$0: Error on line "$LINENO": $BASH_COMMAND"; exit $s' ERR

declare -r VERSION=1.2
declare -r TEMPDIR=${XDG_CACHE_HOME:-"$HOME"/.cache}/local-repo
declare -r CONFDIR=${XDG_CONFIG_HOME:-"$HOME"/.config}/crema
declare REPO=""
declare REPODIR=""

# print_help --- print help text
# usage: print_help
print_help () {
    cat <<EOF
crema $VERSION
Copyright (C) 2019 Michael Picht <https://github.com/mipimipi/crema>

Being a wrapper for repo-add, repo-remove and aurutils, crema helps managing a custom repository that can contain packages from AUR and user-defined (meta) packages.

Usage: crema <command> [<arguments>] 

The commands are:
  add       Add AUR packages to the custom repository
  build     Build packages from a PKGBUILD file and add them to the custom repository  
  env       List the repositories and their directories
  help      Help about any command
  ls        List all packages of the custom repository
  rm        Remove AUR packages from the custom repository
  update    Update all outdated AUR packages in the custom repository  
  version   Display version of crema

Use "crema help <command>" for more information about any command.
EOF
}

# print_help_add --- print help text for add command
# usage: print_help_add
print_help_add () {
    cat <<EOF
Usage: crema add (--repo | -r) <repository> <package> [<packages>]

Add AUR packages incl. the corresponding package tarballs to the custom repository.
EOF
}

# print_help_build --- print help text for build command
# usage: print_help_build
print_help_build () {
    cat <<EOF
Usage: crema build (--repo | -r) <repository> [<path to PKGBUILD>]

Build packages from a PKGBUILD file and add them and the corresponding packages tarballs to the custom repository. If the command is called without a path, it looks for PKGBUILD in the current path.
EOF
}

# print_help_env --- print help text for env command
# usage: print_help_env
print_help_env () {
    cat <<EOF
Usage: crema env

List the repositories that crema knows and their paths.
EOF
}

# print_help_ls --- print help text for ls command
# usage: print_help_ls
print_help_rm () {
    cat <<EOF
Usage: crema ls <repository>

List all packages of the custom repository
EOF
}
# print_help_rm --- print help text for rm command
# usage: print_help_rm
print_help_rm () {
    cat <<EOF
Usage: crema rm (--repo | -r) <repository> <package> [<packages>]

Remove packages and the corresponding package tarballs from the custom repository
EOF
}

# print_help_update --- print help text for update command
# usage: print_help_update
print_help_update () {
    cat <<EOF
Usage: crema update (--repo | -r) <repository>

Update all outdated AUR packages in the custom repository.
EOF
}

# get_repo --- retrieve repo from arguments
# usage: get_repo
get_repo () {
    if [[ -z ${1+x} || $1 != "--repo" && $1 != "-r" ]]
    then
        echo "command expects a repository as argument"
        exit 1
    fi    
    if [[ -z ${2+x} ]]
    then
        echo "command expects a repository as argument"
        exit 1
    fi
    REPO=$2
}    

# read_repodir --- reads repodir from the file .config/crema/$REPO
# usage: read_repodir
read_repodir () {
    if [[ ! -e "$CONFDIR" || ! -d "$CONFDIR" ]]
    then
        mkdir -p "$CONFDIR"
    fi
    if [[ ! -e "$CONFDIR"/"$REPO" ]] 
    then
        read_repodir_from_keyboard
        echo $REPODIR > "$CONFDIR/$REPO"
    else
        mapfile -n 1 -t < "$CONFDIR/$REPO"
        if [[ -z ${MAPFILE[0]+x} || ${MAPFILE[0]} == "" ]]
        then
            read_repodir_from_keyboard
            echo $REPODIR > "$CONFDIR/$REPO"
        else
            REPODIR=${MAPFILE[0]}
        fi
    fi
}

# read_repodir_from_keyboard --- reads repodir from the keyboard input
# usage: read_repodir_from_keyboard
read_repodir_from_keyboard () {
    while [[ -z ${REPODIR+x} || ${REPODIR} == "" ]]
    do
        printf "Enter the path to repository %s (the absolute path is required, SSH is supported, the path is stored in the crema configuration): " $REPO ; read REPODIR
    done
}

# download_repo --- download custom repository (incl. package files) to
# temporary directory
# usage: download_repo
download_repo () {
    # create temporary repository directory
    mkdir -p "$TEMPDIR"
    # sync remote to custom repository
    rsync -a "${REPODIR}/" "${TEMPDIR}"     
}     

# upload_repo --- upload to custom repository (incl. package files) and delete
# temporary directory
# usage: upload_repo
upload_repo () {
    # sync local to remote repository
    rsync -a --delete --no-perms "${TEMPDIR}/" "${REPODIR}"
    # remove temporary directory since it's no longer needed
    rm -rd "${TEMPDIR}"
}    

# crema needs a command
if [ $# = 0 ]
then
    echo -e "crema expects a command\n"
    print_help
    exit 1
fi

case $1 in
add | build | rm | update)
    # save sub command
    cmd=$1
    # get REPO and REPODIR
    shift
    # --- extract repository from cli arguments
    get_repo "$@"
    shift 2
    # --- read path of repository from config
    read_repodir

    case $cmd in
    add)
        # any package to add?
        if [ $# = 0 ]
        then
            echo "no package to add"
            exit 0
        fi
        # download local repo incl. packages files
        download_repo
        # add packages
        aur sync -d "$REPO" --root="$TEMPDIR" -n "$@" || true
        # upload adjusted local repo incl. package files
        upload_repo
        exit 0
        ;;

    build)
        # save current directory
        ORIGDIR=$PWD
        # cd into package directory
        if [ ! -z ${1+x} ]
        then
            cd "$2"
        fi
        # download local repo incl. packages files
        download_repo
        # get packages that are going to be built
        IFS=$'\n' PKGS_ORIG=($(makepkg --packagelist))
        for ((i=0; i<${#PKGS_ORIG[@]}; i++));
        do
            PKGS[i]=${PKGS_ORIG[i]##/*/}
        done
        # build packages and remove temporary files
        makepkg -c
        # mv package files to temp dir
        mv -f *.pkg.tar.xz "$TEMPDIR"
        # add new packages / package versions to custom repository
        cd "$TEMPDIR"
        for pkg in ${PKGS[@]}
        do
            repo-add -n -R "${REPO}.db.tar.xz" "$pkg"
        done    
        cd -
        # upload adjusted local repo incl. package files
        upload_repo
        # cd back to original directory
        cd "$ORIGDIR"
        ;;

    rm)
        # any package to remove?
        if [ $# = 0 ]
        then
            echo "no package to remove"
            exit 0
        fi
        # download local repo incl. packages files
        download_repo
        # remove packages from local repo db and remove package files
        cd "$TEMPDIR"
        repo-remove "${REPO}.db.tar.xz" "$@"
        for pkg in $@
        do
            rm -f "$pkg"*pkg.tar.xz
        done
        cd -
        # upload adjusted local repo incl. package files
        upload_repo
        ;;

    update)
        # download local repo incl. packages files
        download_repo
        # update outdated packages
        cd "$TEMPDIR"
        aur sync -d "$REPO" --root="$TEMPDIR" -u -n || true
        cd -
        # upload adjusted local repo incl. package files
        upload_repo
        ;;
    esac
    ;;

env)
    len=10   # set max length to the length of "REPOSITORY"
    repos=() # repo array
    for path in $(find "$CONFDIR" -type f)
    do
        # remove left part of path to get the repo name
        repo=${path##/*/}
        # store repo in repo array
        repos+=("$repo")
        if [[ $len -lt ${#repo} ]]
        then
            len=${#repo}
        fi
    done
    if [[ ! -z ${repos+x} ]]
    then
        # print headline
        printf "%-${len}s %s\n" "REPOSITORY" "PATH"
        for repo in $repos
        do
            mapfile -n 1 -t < "$CONFDIR/$repo"
            printf "%-${len}s %s\n" $repo ${MAPFILE[0]}
        done
    fi
    ;;    

help)
    shift
    if [ $# = 0 ]
    then
        print_help
        exit 0
    fi
    if [[ $1 != "add" && $1 != "build" && $1 != "env" && $$1 != "ls" && 1 != "rm" && $1 != "update" ]]
    then
        echo "no help available for '$1'"
        exit 1
    fi
    print_help_$1
    ;;

ls)
    shift
    pacman -Sl ${REPO}
    ;;

version)
    echo "crema version $VERSION"
    ;;    

*)
    echo -e "unknown command\n"
    print_help
    exit 1
    ;;
esac

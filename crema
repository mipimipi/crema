#!/bin/bash
#
# Copyright (C) 2019 Michael Picht
#
# This file is part of crema (Custom Repository Management).
#
# crema is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# crema is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with crema. If not, see <http://www.gnu.org/licenses/>.
#
# This script is based on the work of Michael Daffin on managing
# Arch Linux install. See: https://github.com/mdaffin/arch-pkgs

################################################################################
# global declarations
################################################################################

set -uo pipefail
set -o nounset
trap 's=$?; echo "$0: Error on line "$LINENO": $BASH_COMMAND"; exit $s' ERR

declare -r VERSION=1.2
declare -r TEMPDIR=${XDG_CACHE_HOME:-"$HOME"/.tmp}/local-repo
declare -r CFGFILE=${XDG_CONFIG_HOME:-"$HOME"/.config}/crema.conf
declare REPO=""
declare SIGN=false
declare REPODIR=""
declare CMD=""

################################################################################
# functions
################################################################################

# print_help --- print help text
# usage: print_help
print_help () {
    cat <<EOF
crema $VERSION
Copyright (C) 2019 Michael Picht <https://github.com/mipimipi/crema>

crema helps managing custom repositories. These can contain packages from AUR or other, user-defined packages. With crema, packages can be added, removed, built, updated etc.

Usage: crema <command> [<arguments>] 

The commands are:
  add       Add AUR packages to a custom repository
  build     Build packages from one or multiple PKGBUILD file and add them to the custom repository  
  env       List the repositories and their directories
  help      Help about any command
  ls        List all packages of a custom repository
  rm        Remove AUR packages from a custom repository
  update    Update all outdated AUR packages in a custom repository  
  version   Display version of crema

add, build, ls, rm and update require information about the repository that they are to be applied (name and path). This information needs to be maintained in the configuration file \$XDG_CONFIG_HOME/crema.conf in the form <repository-name>|<path-to-repository>. SSH is supported, i.e. the path can be of the form <user>@<server>:<path>.

Use "crema help <command>" for more information about any command.
EOF
}

# print_help_add --- print help text for add command
# usage: print_help_add
print_help_add () {
    cat <<EOF
Usage: crema add (--repo | -r) <repository> <package> [<packages>]

Add AUR packages incl. the corresponding package tarballs to a custom repository.
EOF
}

# print_help_build --- print help text for build command
# usage: print_help_build
print_help_build () {
    cat <<EOF
Usage: crema build (--repo | -r) <repository> [--sign] [<paths to PKGBUILD>]

Build packages from one or multiple PKGBUILD files and add them and the corresponding packages tarballs to a custom repository. If the command is called without any path, it looks for PKGBUILD in the current directory.
If --sign is set, the package is signed with gpg. The key id is taken from the environment variable GPGKEY which can be set in the configuration file of makepkg (see https://wiki.archlinux.org/index.php/Makepkg).
EOF
}

# print_help_env --- print help text for env command
# usage: print_help_env
print_help_env () {
    cat <<EOF
Usage: crema env

List the repositories that crema knows and their paths.
EOF
}

# print_help_ls --- print help text for ls command
# usage: print_help_ls
print_help_rm () {
    cat <<EOF
Usage: crema ls <repository>

List all packages of a custom repository
EOF
}
# print_help_rm --- print help text for rm command
# usage: print_help_rm
print_help_rm () {
    cat <<EOF
Usage: crema rm (--repo | -r) <repository> <package> [<packages>]

Remove packages and the corresponding package tarballs from a custom repository
EOF
}

# print_help_update --- print help text for update command
# usage: print_help_update
print_help_update () {
    cat <<EOF
Usage: crema update (--repo | -r) <repository>

Update all outdated AUR packages in a custom repository.
EOF
}

# print_help_update --- print help text for version command
# usage: print_help_version
print_help_version () {
    cat <<EOF
Usage: crema version

Displays the version of crema.
EOF
}

# read_repodir --- reads repodir from the file $CFGFILE (i.e. '.config/crema.cfg')
# usage: read_repodir
read_repodir () {
    # check if the config file exists
    if [[ ! -e $CFGFILE ]]
    then
        echo "a repository path for '$REPO'needs to be maintained in $CFGFILE"
        exit 1
    fi
    REPODIR=$(sed -n -e "/${REPO}/s/^${REPO}|\(.*\)/\1/p" < $CFGFILE)
    # check if path to repository could be determined
    if [[ -z ${REPODIR+x} ]] || [[ $REPODIR = "" ]]
    then
        echo "a repository path for '$REPO'needs to be maintained in $CFGFILE"
        exit 1
    fi
}

# exec_makepkg --- execute makepkg
# usage: exec_makepkg <path-to-PKGBUILD>
exec_makepkg () {
    # save current directory
    local ORIGDIR=$PWD
    # cd into package directory
    if [ ! -z ${1+x} ]
    then
        cd "$1"
    fi
    # download local repo incl. packages files
    download_repo
    # get packages that are going to be built
    IFS=$'\n' PKGS_ORIG=($(makepkg --packagelist))
    for ((i=0; i<${#PKGS_ORIG[@]}; i++));
    do
        PKGS[i]=${PKGS_ORIG[i]##/*/}
    done
    # build packages (and sign them if required) and remove temporary files
    if [[ $SIGN == true ]]
    then
        makepkg -c --sign
    else
        makepkg -c
    fi  
    # mv package files to temp dir
    mv -f *.pkg.tar.xz* "$TEMPDIR"
    # add new packages / package versions to custom repository
    cd "$TEMPDIR"
    for pkg in ${PKGS[@]}
    do
        repo-add -n -R "${REPO}.db.tar.xz" "$pkg"
    done    
    cd -
    # upload adjusted local repo incl. package files
    upload_repo
    # cd back to original directory
    cd "$ORIGDIR"
}

# download_repo --- download custom repository (incl. package files) to
# temporary directory
# usage: download_repo
download_repo () {
    # create temporary repository directory
    mkdir -p "$TEMPDIR"
    # sync remote to custom repository
    rsync -a "${REPODIR}/" "${TEMPDIR}"     
}     

# upload_repo --- upload to custom repository (incl. package files) and delete
# temporary directory
# usage: upload_repo
upload_repo () {
    # sync local to remote repository
    rsync -a --delete --no-perms "${TEMPDIR}/" "${REPODIR}"
    # remove temporary directory since it's no longer needed
    rm -rd "${TEMPDIR}"
}    

################################################################################
# main program
################################################################################

# crema needs a command
if [[ $# = 0 ]]
then
    echo "crema expects a command"
    exit 1
fi

# check command
if [[ $1 != "add" && $1 != "build" && $1 != "env" && $1 != "help" && $1 != "--help" && $1 != "-h" && $1 != "ls" && 1 != "rm" && $1 != "update" && $1 != "version" ]]
then
   echo "crema $1: unknown command. Run 'crema help' for usage."
   exit 1
fi
# set CMD
case $1 in
    --help | -h)
        CMD="help"
        ;;
    *)
        CMD=$1
        ;;
esac
shift

# retrieve arguments
while [ $# -gt 0 ]
do
    case $1 in
        --repo | -r)
            # check if repository has been specified
            if [[ -z ${2+x} ]] || [[ $2 = "" ]]
            then
                echo "command needs a repository"
                exit 1
            fi
            REPO=$2
            shift 2
            ;;
        --sign)
            # check if gpg key is set
            #if [[ -z ${GPGKEY+x} ]] || [[ $GPGKEY = "" ]]
            #then
            #    echo "gpg key needs to be set in variable GPGKEY"
            #    exit 1
            #fi
            SIGN=true
            shift
            ;;
        *)
            break
            ;;
    esac
done

case $CMD in
    add)
        # any package to add?
        if [[ $# = 0 ]]
        then
            echo "no package to add"
            exit 0
        fi
        # get path to repository
        read_repodir
        # download local repo incl. packages files
        download_repo
        # add packages
        aur sync -d "$REPO" --root="$TEMPDIR" -n "$@" || true
        # upload adjusted local repo incl. package files
        upload_repo
        exit 0
        ;;

    build)
        read_repodir
        # if list of PKGBUILD paths is empty ...
        if [[ $# = 0 ]]
        then
            # ... assume that PKGBUILD is in current path
            exec_makepkg "$PWD"
        else
            # otherwise: call makepkg for every path of the argument list
            for path in "$@"
            do
                exec_makepkg "$1"
            done
        fi
        ;;

    env)
        [[ -e $CFGFILE ]] || exit 0

        # initialize local variables
        declare -i len=10      # set max length to the length of "REPOSITORY"
        declare -i counter=0   # count number of entries
        declare -a repos=()    # repository array
        declare -a repodirs=() # array of repo paths
        
        while IFS='|' read repo repodir
        do
            if [[ $len -lt ${#repo} ]]
            then
                len=${#repo}
            fi
            repos+=($repo)
            repodirs+=($repodir)
            counter+=1
        done < $CFGFILE
        # nothing to do if conf file doesn't contain repo data
        [[ $counter -gt 0 ]] ||  exit 0
        # print headline
        printf "%-${len}s %s\n" "REPOSITORY" "PATH"
        # print content
        for ((i=0; i<$counter; i++));
        do
            printf "%-${len}s %s\n" ${repos[i]} ${repodirs[i]}
        done
        ;;    

    help)
        if [[ $# = 0 ]]
        then
            print_help
            exit 0
        fi
        if [[ $1 != "add" && $1 != "build" && $1 != "env" && $$1 != "ls" && 1 != "rm" && $1 != "update" && $1 != "version" ]]
        then
            echo "no help available for '$1'"
            exit 1
        fi
        print_help_$1
        ;;

    ls)
        shift
        pacman -Sl ${REPO}
        ;;

    rm)    
        # any package to remove?
        if [[ $# = 0 ]]
        then
            echo "no package to remove"
            exit 0
        fi
        read_repodir
        # download local repo incl. packages files
        download_repo
        # remove packages from local repo db and remove package files
        cd "$TEMPDIR"
        repo-remove "${REPO}.db.tar.xz" "$@"
        for pkg in $@
        do
            rm -f "$pkg"*pkg.tar.xz
        done
        cd -
        # upload adjusted local repo incl. package files
        upload_repo
        ;;

    update)
        read_repodir
        # download local repo incl. packages files
        download_repo
        # update outdated packages
        cd "$TEMPDIR"
        aur sync -d "$REPO" --root="$TEMPDIR" -u -n || true
        cd -
        # upload adjusted local repo incl. package files
        upload_repo
        ;;

    version)
        echo "crema version $VERSION"
        ;;    

    *)
        echo -e "unknown command\n"
        print_help
        exit 1
        ;;
esac

#!/bin/bash
#
# Copyright (C) 2019 Michael Picht
#
# This file is part of crema (Custom Repository Management).
#
# crema is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# crema is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with crema. If not, see <http://www.gnu.org/licenses/>.
#
# This script is based on the work of Michael Daffin on managing
# Arch Linux install. See: https://github.com/mdaffin/arch-pkgs

################################################################################
# global declarations
################################################################################

set -uo pipefail
set -o nounset
trap 's=$?; echo "$0: Error on line "$LINENO": $BASH_COMMAND"; exit $s' ERR

declare -r VERSION=1.3
declare -r TEMPDIR=${XDG_DATA_HOME:-"$HOME"/.local}/crema/local-repo
declare -r CHROOTDIR=${XDG_DATA_HOME:-"$HOME"/.local}/crema/chroots
declare -r CFGFILE=${XDG_CONFIG_HOME:-"$HOME"/.config}/crema.conf
declare REPO=""
declare SIGN=false
declare CHROOT=false
declare REPODIR=""
declare CMD=""

################################################################################
# functions
################################################################################

# print_help --- print help text
# usage: print_help
print_help () {
    cat <<EOF
crema $VERSION
Copyright (C) 2019 Michael Picht <https://github.com/mipimipi/crema>

crema helps managing custom repositories. These can contain packages from AUR or other, user-defined packages. With crema, packages can be added, removed, built, updated etc.

Usage: crema <command> [<arguments>] 

The commands are:
  add       Add AUR packages to a custom repository
  build     Build packages from one or multiple PKGBUILD file and add them to the custom repository  
  cleanup   Clean up database of one or all custom repositories
  env       List the repositories and their directories
  help      Help about any command
  ls        List all packages of one or all custom repositories
  rm        Remove AUR packages from a custom repository
  update    Update all outdated AUR packages of one or all custom repositories  
  version   Display version of crema

Use "crema help <command>" for more information about any command.

EOF
}

# print_help_add --- print help text for add command
# usage: print_help_add
print_help_add () {
    cat <<EOF
Usage: crema add (--repo | -r) <repository> <package> [<packages>]

Add AUR packages incl. the corresponding package tarballs to a custom repository.

Flags:
-r --repo <repo> Use custom repository <repo>. For data transfer, the path to
                 the repository is needed. It needs to be maintained in the
                 configuration file \$XDG_CONFIG_HOME/crema.conf in the form
                 <repository-name>|<path-to-repository>. SSH is supported,
                 i.e. the path can be of the form <user>@<server>:<path>.

EOF
}

# print_help_build --- print help text for build command
# usage: print_help_build
print_help_build () {
    cat <<EOF
Usage: crema build (--repo | -r) <repository> [--sign] [--chroot] [<paths to PKGBUILD>]

Build packages from one or multiple PKGBUILD files and add them and the corresponding packages tarballs to a custom repository. If the command is called without any path, it looks for PKGBUILD in the current directory.

Flags:
   --chroot      Build the package using makechrootpkg. Otherwise makepkg is
                 used.
-r --repo <repo> Use custom repository <repo>. For data transfer, the path to
                 the repository is needed. It needs to be maintained in the
                 configuration file \$XDG_CONFIG_HOME/crema.conf in the form
                 <repository-name>|<path-to-repository>. SSH is supported,
                 i.e. the path can be of the form <user>@<server>:<path>.
   --sign        Sign the package with gpg. The key id is taken from the
                 enironment variable GPGKEY which can be set in the
                 configuration file of makepkg (see
                 https://wiki.archlinux.org/index.php/Makepkg).

EOF
}

# print_help_cleanup --- print help text for cleanup command
# usage: print_help_cleanup
print_help_cleanup () {
    cat <<EOF
Usage: crema cleanup [(--repo | -r) <repository>]

Cleanup repository database. If no repository is given, then the cleanup is done for all custom repositories. Otherwise only the database of the given repository are cleaned up.

Flags:
-r --repo <repo> Use custom repository <repo>. For data transfer, the path to
                 the repository is needed. It needs to be maintained in the
                 configuration file \$XDG_CONFIG_HOME/crema.conf in the form
                 <repository-name>|<path-to-repository>. SSH is supported,
                 i.e. the path can be of the form <user>@<server>:<path>.

EOF
}

# print_help_env --- print help text for env command
# usage: print_help_env
print_help_env () {
    cat <<EOF
Usage: crema env

List the repositories that crema knows and their paths.

EOF
}

# print_help_ls --- print help text for ls command
# usage: print_help_ls
print_help_ls () {
    cat <<EOF
Usage: crema ls [<repository>]

List all packages. If no repository is given, then that's done for all custom repositories. Otherwise only the packages of the given repository are listed.

Flags:
-r --repo <repo> Use custom repository <repo>. For data transfer, the path to
                 the repository is needed. It needs to be maintained in the
                 configuration file \$XDG_CONFIG_HOME/crema.conf in the form
                 <repository-name>|<path-to-repository>. SSH is supported,
                 i.e. the path can be of the form <user>@<server>:<path>.

EOF
}

# print_help_rm --- print help text for rm command
# usage: print_help_rm
print_help_rm () {
    cat <<EOF
Usage: crema rm (--repo | -r) <repository> <package> [<packages>]

Remove packages and the corresponding package tarballs from a custom repository

Flags:
-r --repo <repo> Use custom repository <repo>. For data transfer, the path to
                 the repository is needed. It needs to be maintained in the
                 configuration file \$XDG_CONFIG_HOME/crema.conf in the form
                 <repository-name>|<path-to-repository>. SSH is supported,
                 i.e. the path can be of the form <user>@<server>:<path>.

EOF
}

# print_help_update --- print help text for update command
# usage: print_help_update
print_help_update () {
    cat <<EOF
Usage: crema update [(--repo | -r) <repository>]

Update all outdated AUR packages. If no repository is given, then that's done for all custom repositories. Otherwise only the packages of the given repository are updated.

Flags:
-r --repo <repo> Use custom repository <repo>. For data transfer, the path to
                 the repository is needed. It needs to be maintained in the
                 configuration file \$XDG_CONFIG_HOME/crema.conf in the form
                 <repository-name>|<path-to-repository>. SSH is supported,
                 i.e. the path can be of the form <user>@<server>:<path>.

EOF
}

# print_help_update --- print help text for version command
# usage: print_help_version
print_help_version () {
    cat <<EOF
Usage: crema version

Displays the version of crema.

EOF
}

# read_db --- reads database of repo $REPO
# usage: read_db
read_db () {
    local -a pkgs
    local pkg

    mapfile -t pkgs < <( tar -tf "${TEMPDIR}/${REPO}.db.tar.xz")

    for pkg in "${pkgs[@]}"
    do
        if [[ $pkg =~ .+/$ ]]
        then
            echo "$REPO ${pkg%/}"
        fi    
    done
}    

# read_repodir --- reads repodir from the file $CFGFILE (i.e. '.config/crema.cfg')
# usage: read_repodir
read_repodir () {
    # check if the config file exists
    if [[ ! -e $CFGFILE ]]
    then
        echo "a repository path for '$REPO' needs to be maintained in $CFGFILE"
        exit 1
    fi
    REPODIR=$(sed -n -e "/${REPO}/s/^${REPO}|\(.*\)/\1/p" < "$CFGFILE")
    # check if path to repository could be determined
    if [[ -z ${REPODIR+x} ]] || [[ $REPODIR = "" ]]
    then
        echo "a repository path for '$REPO' needs to be maintained in $CFGFILE"
        exit 1
    fi
}


# clean_up --- do cleanup
# usage: clean_up
clean_up () {
    # loop at all packages of the repo $REPO
    read_db | cut -d " " -f 2 | while read -r pkg
    do
        if [[ -z $(find "$TEMPDIR" -maxdepth 1 -name "${pkg}*.pkg.tar.xz") ]]
        then
            echo "removing $pkg from $REPO"
            repo-remove "${TEMPDIR}/${REPO}.db.tar.xz" "$pkg"
        fi
    done
}

# exec_cleanup --- execute cleanup
# usage: exec_cleanup
exec_cleanup () {
    # download local repo incl. packages files
    download_repo
    # list packages
    clean_up
    # upload adjusted local repo incl. package files
    upload_repo
}

# exec_ls --- execute package listing
# usage: exec_ls
exec_ls () {
    # download local repo incl. packages files
    download_repo
    # list packages
    read_db
    # upload adjusted local repo incl. package files
    upload_repo
}

# exec_makepkg --- execute makepkg
# usage: exec_makepkg <path-to-PKGBUILD>
exec_makepkg () {
    # save current directory
    local ORIGDIR=$PWD
    # cd into package directory
    if [[ -n "$1" ]]
    then
        cd "$1"
    fi
    # download local repo incl. packages files
    download_repo
    # get packages that are going to be built
    IFS=$'\n' PKGS_ORIG=($(makepkg --packagelist))
    for ((i=0; i<${#PKGS_ORIG[@]}; i++));
    do
        PKGS[i]=${PKGS_ORIG[i]##/*/}
    done
    # build packages (sign them if required) and remove temporary files
    if [[ $CHROOT == true ]]
    then
        if [[ ! -d "${CHROOTDIR}" ]]
        then
            mkdir -p "${CHROOTDIR}"
            mkarchroot "${CHROOTDIR}/root" base-devel
        fi
        makechrootpkg -cu -r "${CHROOTDIR}"
        if [[ $SIGN == true ]]
        then
            if [[ ! -z ${1+GPGKEY} ]]
            then
                for pkg in "${PKGS[@]}"
                do
                    gpg -u $GPGKEY --output ${pkg}.sig --detach-sign $pkg
                done    
            else
                echo "GPGKEY is not set. Package couldn't be signed."
            fi
        fi  
    else
        if [[ $SIGN == true ]]
        then
            makepkg -c --sign
        else
            makepkg -c
        fi  
    fi    
    # mv package files to temp dir
    mv -f *.pkg.tar.xz* "$TEMPDIR"
    # add new packages / package versions to custom repository
    cd "$TEMPDIR"
    for pkg in "${PKGS[@]}"
    do
        repo-add -n -R "${REPO}.db.tar.xz" "$pkg"
    done    
    cd -
    # upload adjusted local repo incl. package files
    upload_repo
    # cd back to original directory
    cd "$ORIGDIR"
}

# exec_update --- execute update
# usage: exec_update
exec_update () {
    # download local repo incl. packages files
    download_repo
    # update only makes sense if there's already a database
    if [[ -e "${TEMPDIR}/${REPO}.db.tar.xz" ]]
    then
        # update outdated packages
        cd "$TEMPDIR"
        aur sync -d "$REPO" --root="$TEMPDIR" -u -n || true
        # remove opsolete package files
        clean_up
        cd -
        # upload adjusted local repo incl. package files
        upload_repo
    fi
}        

# download_repo --- download custom repository (incl. package files) to
# temporary directory
# usage: download_repo
download_repo () {
    # create temporary repository directory
    mkdir -p "$TEMPDIR"
    # sync remote to custom repository
    rsync -a "${REPODIR}/" "${TEMPDIR}"     
}     

# upload_repo --- upload to custom repository (incl. package files) and delete
# temporary directory
# usage: upload_repo
upload_repo () {
    # sync local to remote repository
    rsync -a --delete --no-perms "${TEMPDIR}/" "${REPODIR}"
    # remove temporary directory since it's no longer needed
    rm -rd "${TEMPDIR}"
}    

################################################################################
# main program
################################################################################

# crema needs a command
if [[ $# = 0 ]]
then
    echo "crema expects a command"
    exit 1
fi

# check command
if [[ $1 != "add" && $1 != "build" && $1 != "cleanup" && $1 != "env" && $1 != "help" && $1 != "--help" && $1 != "-h" && $1 != "ls" && $1 != "rm" && $1 != "update" && $1 != "version" ]]
then
   echo "crema $1: unknown command. Run 'crema help' for usage."
   exit 1
fi
# set CMD
case $1 in
    --help | -h)
        CMD="help"
        ;;
    *)
        CMD=$1
        ;;
esac
shift

# retrieve arguments
while [ $# -gt 0 ]
do
    case $1 in
        --repo | -r)
            # check if repository has been specified
            if [[ -z ${2+x} ]] || [[ $2 = "" ]]
            then
                echo "command needs a repository"
                exit 1
            fi
            REPO=$2
            shift 2
            ;;
        --sign)
            SIGN=true
            shift
            ;;
        --chroot)
            CHROOT=true
            shift
            ;;
        *)
            break
            ;;
    esac
done

case $CMD in
    add)
        # any package to add?
        if [[ $# = 0 ]]
        then
            echo "no package to add"
            exit 0
        fi
        # get path to repository
        read_repodir
        # download local repo incl. packages files
        download_repo
        # if there's no database yet: create it
        if [[ ! -e "${TEMPDIR}/${REPO}.db.tar.xz" ]]
        then
            repo-add -n -R "${TEMPDIR}/${REPO}.db.tar.xz"
        fi
        # add packages
        aur sync -d "$REPO" --root="$TEMPDIR" -n "$@" || true
        # upload adjusted local repo incl. package files
        upload_repo
        exit 0
        ;;

    build)
        read_repodir
        # if list of PKGBUILD paths is empty ...
        if [[ $# = 0 ]]
        then
            # ... assume that PKGBUILD is in current path
            exec_makepkg "$PWD"
        else
            # otherwise: call makepkg for every path of the argument list
            for path in "$@"
            do
                exec_makepkg "$1"
            done
        fi
        ;;

    cleanup)
        # if a repo has been specified: ...
        if [[ -n $REPO ]]
        then
            # ... cleanup that repo, ...
            read_repodir
            exec_cleanup
        else
            # ... otherwise: cleanup all repos
            while IFS='|' read REPO REPODIR
            do
                if [[ ${#REPO} = 0 ]]
                then
                    continue
                fi
                exec_cleanup
            done < $CFGFILE
        fi
        ;;

    env)
        [[ -e $CFGFILE ]] || exit 0

        # initialize local variables
        declare -i len=10      # set max length to the length of "REPOSITORY"
        declare -i counter=0   # count number of entries
        declare -a repos=()    # repository array
        declare -a repodirs=() # array of repo paths
        
        # determine length of repo column
        while IFS='|' read repo repodir
        do
            if [[ ${#repo} = 0 ]]
            then
                continue
            fi
            if [[ $len -lt ${#repo} ]]
            then
                len=${#repo}
            fi
            repos+=($repo)
            repodirs+=($repodir)
            counter+=1
        done < $CFGFILE
        # nothing to do if conf file doesn't contain repo data
        [[ $counter -gt 0 ]] ||  exit 0
        # print headline
        printf "%-${len}s %s\n" "REPOSITORY" "PATH"
        # print content
        for ((i=0; i<$counter; i++));
        do
            printf "%-${len}s %s\n" ${repos[i]} ${repodirs[i]}
        done
        ;;    

    help)
        if [[ $# = 0 ]]
        then
            print_help
            exit 0
        fi
        if [[ $1 != "add" && $1 != "build" && $1 != "cleanup" && $1 != "env" && $1 != "ls" && $1 != "rm" && $1 != "update" && $1 != "version" ]]
        then
            echo "no help available for '$1'"
            exit 1
        fi
        print_help_$1
        ;;

    ls)
        # if repo has been specified: ...
        if [[ -n $REPO ]]
        then
            # ... list packages of that repo, ...
            read_repodir
            exec_ls
        else    
            # ... otherwise: update all repos
            while IFS='|' read -r REPO REPODIR
            do
                if [[ ${#REPO} = 0 ]]
                then
                    continue
                fi
                exec_ls
            done < $CFGFILE
        fi    
        ;;

    rm)   
        # any package to remove?
        if [[ $# = 0 ]]
        then
            echo "no package to remove"
            exit 0
        fi
        read_repodir
        # download local repo incl. packages files
        download_repo
        # removal only makes sense if there's already a database
        if [[ -e "${TEMPDIR}/${REPO}.db.tar.xz" ]]
        then
            # remove packages from local repo db and remove package files
            cd "$TEMPDIR"
            repo-remove "${REPO}.db.tar.xz" "$@"
            for pkg in "$@"
            do
                rm -f "$pkg"*pkg.tar.xz
            done
            cd -
            # upload adjusted local repo incl. package files
            upload_repo
        fi    
        ;;

    update)
        # if repo has been specified: ...
        if [[ -n $REPO ]]
        then
            # ... update repo that is specified, ...
            read_repodir
            exec_update
        else    
            # ... otherwise: update all repos
            while IFS='|' read -r REPO REPODIR
            do
                if [[ ${#REPO} = 0 ]]
                then
                    continue
                fi
                exec_update
            done < $CFGFILE
        fi    
        ;;

    version)
        echo "crema version $VERSION"
        ;;    

    *)
        echo -e "unknown command\n"
        print_help
        exit 1
        ;;
esac

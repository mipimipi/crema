#!/bin/bash
#
# Copyright (C) 2019 Michael Picht
#
# This file is part of crema (Custom Repository Management).
#
# crema is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# crema is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with crema. If not, see <http://www.gnu.org/licenses/>.

################################################################################
# global declarations                                                          #
################################################################################

set -uo pipefail
set -o nounset
#trap 's=$?; echo "$0: Error on line "$LINENO": $BASH_COMMAND"; crema_exit $s' ERR

declare -r VERSION=1.5
declare -r TEMPREPODIR=${XDG_DATA_HOME:-"$HOME"/.local}/crema/local-repo
declare -r PKGDIR=${XDG_DATA_HOME:-"$HOME"/.local}/crema/pkg
declare -r TEMPFILE=${XDG_DATA_HOME:-"$HOME"/.local}/crema/temp.file
declare -r CFGFILE=${XDG_CONFIG_HOME:-"$HOME"/.config}/crema.conf
declare -r CHROOTDIR=/var/lib/aurbuild/$(uname -m)
declare CMD=               # sub command
declare SIGNARGS_AUR=      # sign arguments for aurutils
declare SIGNARGS_REPO=     # sign arguments for repo-* tools
declare MAKEARGS=("-c" "--" "--" "-c")
                           # chroot arguments (chroot is the default)
declare -a REMARGS=()      # remaining arguments
declare REPO=              # repository
declare REPODIR=           # remote repository directory
declare SOURCE=            # source for add sub command. Can be either "aur"
                           # or "local" 


################################################################################
# messages (taken from makepkg coding)                                         #
################################################################################

colorize() {
    # prefer terminal safe colored and bold text when tput is supported
    if tput setaf 0 &>/dev/null; then
        ALL_OFF="$(tput sgr0)"
        BOLD="$(tput bold)"
        BLUE="${BOLD}$(tput setaf 4)"
        GREEN="${BOLD}$(tput setaf 2)"
        RED="${BOLD}$(tput setaf 1)"
        YELLOW="${BOLD}$(tput setaf 3)"
    else
        ALL_OFF="\e[0m"
        BOLD="\e[1m"
        BLUE="${BOLD}\e[34m"
        GREEN="${BOLD}\e[32m"
        RED="${BOLD}\e[31m"
        YELLOW="${BOLD}\e[33m"
    fi
    readonly ALL_OFF BOLD BLUE GREEN RED YELLOW
}
 
plain() {
    local mesg=$1; shift
    printf "${BOLD}    ${mesg}${ALL_OFF}\n" "$@" >&2
}
 
msg() {
    local mesg=$1; shift
    printf "${GREEN}==>${ALL_OFF}${BOLD} ${mesg}${ALL_OFF}\n" "$@" >&2
}
 
msg2() {
    local mesg=$1; shift
    printf "${BLUE}  ->${ALL_OFF}${BOLD} ${mesg}${ALL_OFF}\n" "$@" >&2
}
 
warning() {
    local mesg=$1; shift
    printf "${YELLOW}==> $(gettext "WARNING:")${ALL_OFF}${BOLD} ${mesg}${ALL_OFF}\n" "$@" >&2
}
 
error() {
    local mesg=$1; shift
    printf "${RED}==> $(gettext "ERROR:")${ALL_OFF}${BOLD} ${mesg}${ALL_OFF}\n" "$@" >&2
}


################################################################################
# help                                                                         #
################################################################################

# print_help --- print help text
# usage: print_help <topic>
print_help () {
    # set help topic
    if [[ -z ${1+x} ]]
    then
        topic=""
    else
        topic=$1
    fi    

    case $topic in
        add)
cat <<EOF
Usage: crema add (--repo | -r) <repository> [(--sign | -s)] [(--nochroot | -n)] 
                   <package sources>

Build and add packages to a repository. The packages (their PKGBUILD files)) can
either come from AUR or from the local file system.

Flags:
-n       --nochroot    Per default, makechrootpkg is used to build packages. If
                       this flag is set, makepkg (outside of a chroot
                       environment) is used instead.
-r       --repo <repo> Add package(s) to the custom repository <repo>.
-s       --sign        Sign the new packages and the repository database with
                       gpg.

Package sources:
<package sources> define the source(s) of the PKGBUILD files that are needed to
build the packages. Two different forms are supported (which cannot be combined 
in the same crema build statement):
-f:aur   --from:aur    Build packages from AUR. This flag must be followed by a
                       list of AUR package names.
-f:local --from:local  Build packages whose PKGBUILD files are located in the
                       local file system. This flag can be followed by a list
                       of directories where the PKGBUILD files are stored. If no
                       directory is given, crema assumes a PKGBUILD file in the
                       current directory.

Environment:
GPGKEY                 Id of the key that is used by gpg for signing.

EOF
            ;;
        cleanup)
cat <<EOF
Usage: crema cleanup [(--repo | -r) <repository>]

Cleanup repository database. If no repository is given, then the cleanup is done
for all custom repositories. Otherwise only the database of the given repository
are cleaned up.

Flags:
-r --repo <repo> Clean up the custom repository <repo>.

EOF
            ;;
        chroot-add-key)
cat <<EOF
Usage: crema chroot-add-key <key ID>

Add a key <key ID> to the chroot environment.

EOF
            ;;
        chroot-rm)
cat <<EOF
Usage: crema chroot-rm

Remove/reset the chroot environment.

EOF
            ;;
        env)
cat <<EOF
Usage: crema env

List the repositories that crema knows and their paths.

EOF
            ;;
        ls)
cat <<EOF
Usage: crema ls [(--repo | -r) <repository>]

List all packages. If no repository is given, then that's done for all custom
repositories. Otherwise only the packages of the given repository are listed.

Flags:
-r --repo <repo> List packages of the custom repository <repo>. 

EOF
            ;;
        purge)
cat <<EOF
Usage: crema purge (--repo | -r) <repository>

Delete all package and the package database from a custom repository

Flags:
-r --repo <repo> Delete all packages from the custom repository <repo>. 

EOF
            ;;
        repo-add)
cat <<EOF
Usage: crema repo-add (--repo | -r) <repository> (--path | p ) <path-to-repo>

Add a custom repository to the crema configuration.

Flags:
-r --repo <repo> Add the custom repository <repo> ...
-p --path <path> ... with the path <path>. The path must be compliant to rsync.
                 SSH is supported, i.e. the path can be of the form
                 <user>@<host>:<directory.

EOF
            ;;
        repo-rm)
cat <<EOF
Usage: crema repo-rm <repository>

Remove a custom repository from the crema configuration.

Flags:
-r --repo <repo> Remove the custom repository <repo>

EOF
            ;;
        rm)
cat <<EOF
Usage: crema rm (--repo | -r) <repository> <package> [<packages>]

Remove packages and the corresponding package tarballs from a custom repository

Flags:
-r --repo <repo> Remove package(s) from the custom repository <repo>
-s --sign        Sign the repository database with gpg.

Environment:
GPGKEY           Id of the key that is used by gpg for signing.

EOF
            ;;
        sign)
cat <<EOF
Usage: crema sign (--repo | -r) <repository>

Sign a repository, incl. the repository database and all package files.

Flags:
-r --repo <repo> Sign the custom repository <repo>

Environment:
GPGKEY           Id of the key that is used by gpg for signing.

EOF
            ;;
        unsign)
cat <<EOF
Usage: crema unsign (--repo | -r) <repository>

Remove signatures from a repository, i.e. all *.sig files are deleted, incl.
the *.sig files of the repository database and all package files.

Flags:
-r --repo <repo> Unsign the custom repository <repo>.

EOF
            ;;
        update)
cat <<EOF
Usage: crema update [(--repo | -r) <repository>]

Update all outdated AUR packages. If no repository is given, then that's done
for all custom repositories. Otherwise only the packages of the given repository
are updated.

Flags:
-n --nochroot     Per default, makechrootpkg is used to build packages. If this
                  flag is set, makepkg (outside of a chroot environment) is used
                  instead.
-r --repo <repo>  Update the packages of the custom repository <repo>.
-s --sign         Sign the package files of the updated packages and the
                  repository database with gpg.

Environment:
GPGKEY            Id of the key that is used by gpg for signing.

EOF
            ;;
        version)
cat <<EOF
Usage: crema version

Displays the version of crema.

EOF
            ;;
        *)
cat <<EOF
crema $VERSION
Copyright (C) 2019 Michael Picht <https://github.com/mipimipi/crema>

crema helps managing custom repositories. These can contain packages from AUR or
other, user-defined packages. With crema, packages can be added, removed, built,
updated etc.

Usage: crema <command> [<arguments>] 

The commands are:
  add             Build and add packages either from AUR or local file system to
                  a custom repository
  cleanup         Clean up database of one or all custom repositories
  chroot-add-key  Add gpg key to the chroot environment
  chroot-rm       Remove the chroot environment
  env             List the repositories and their directories
  help            Help about any command
  ls              List all packages of one or all custom repositories
  purge           Delete all packages from a custom repository
  rm              Remove AUR packages from a custom repository
  repo-add        Add a custom repository to the configuration of crema.
  repo-rm         Remove a custom repository from the configuration of crema
  sign            Sign a custom repository with gpg
  unsign          Remove signatures from a custom repository
  update          Update all outdated AUR packages of one or all custom
                  repositories  
  version         Display version of crema

Environment:
GPGKEY         Id of the key that is used by gpg for signing.

Use "crema help <command>" for more information about any command.

EOF
            ;;
    esac
}


################################################################################
# functions                                                                    #
################################################################################

# check_repo --- checks if REPO is set
# usage: check_repo
check_repo () {
    if [[ -z ${REPO+x} || $REPO = "" ]]
    then
        error "Repository required"
        crema_exit 1
    fi
}    

# cleanup_repo --- clean up repository in local directory
# usage: cleanup_repo
cleanup_repo () {
    # check if all package in the repo db have corresponding package
    # files
    read_db | cut -d " " -f 2 | while read -r pkg
    do
        if [[ -z $(find "$TEMPREPODIR" -maxdepth 1 -name "${pkg}*.pkg.tar.xz") ]]
        then
            repo-remove ${SIGNARGS_REPO[@]} "${TEMPREPODIR}/${REPO}.db.tar.xz" \
                "$pkg"
            plain "Package file for \'$pkg\' doesnt' exist: Package removed from repository"
        fi
    done

    # check if all package file are represented in the repo db
    mapfile -t pkgs < <( tar -tf "${TEMPREPODIR}/${REPO}.db.tar.xz")
    for file in "$TEMPREPODIR"/*.pkg.tar.xz
    do
        # extract package name from $file
        pkg=${file##/*/}
        pkg=${pkg%-*.pkg.tar.xz}
        # check if repo contains that package, if not: remove files
        if [[ ! " ${pkgs[@]} " =~ " $pkg/" ]]
        then
            rm -f "$file" "$file".sig
            plain "\'$pkg\' not contained in repository database: Package file(s) removed"
        fi
    done

    # check if every sig file has a corresponding data file
    for file in "$TEMPREPODIR"/*.sig
    do
        [[ -e $file ]] || continue
        if [[ ! -e "$file%.sig" ]]
        then
            rm -f "$file"
            plain "\'${file##/*/}\' doesn't have a corresponding data file: File removed"
        fi
    done
}
    
# cleanup_temp --- clean up temp data
# usage: cleanup_temp
cleanup_temp () {
    rm -rdf "$TEMPREPODIR" "$PKGDIR"
    rm -f "$TEMPFILE"
}

# crema_exit --- delete temporary data and exit the program
# usage: crema_exit <exit-code>
crema_exit () {
    rm -rdf $TEMPREPODIR $PKGDIR
    rm -f $TEMPFILE
    exit $1
}

# download_repo --- download custom repository (incl. package files) to
# temporary directory
# usage: download_repo <scope> where scope can either be 'all' (which donwloads
# all files) or 'db' (which downloads only the repo database) 
download_repo () {
    # create temporary repository directory
    mkdir -p "$TEMPREPODIR"

    case $1 in
        db)
            msg "downloading from \'$REPODIR\' ..."
            # sync remote to custom repository
            rsync -az --include "$REPO.db.tar.xz" --exclude "*" "${REPODIR}/" "${TEMPREPODIR}"     
            # verify gpg signature of repo
            verify_signature "$TEMPREPODIR/$REPO.db.tar.xz"
            ;;
        all)    
            msg "downloading from \'$REPODIR\' ..."
            # sync remote to custom repository
            rsync -az "${REPODIR}/" "${TEMPREPODIR}"     
            # verify gpg signature of repo
            verify_signature "$TEMPREPODIR/$REPO.db.tar.xz"
            verify_signature "$TEMPREPODIR/$REPO.files.tar.xz"
            ;;
        *)    
            error "Wrong scope for \'download_repo\'"
            crema_exit 1
            ;;
    esac
}     

# parse_args --- parse command line arguments
# usage: parse_args <command-line-arguments>
parse_args () {
    # crema needs a command
    if [[ $# = 0 ]]
    then
        error "crema expects a command"
        crema_exit 1
    fi

    # check command
    if [[ $1 != "add" && $1 != "cleanup" && $1 != "chroot-add-key" \
        && $1 != "chroot-rm" && $1 != "env" && $1 != "help" && $1 != "--help" \
        && $1 != "-h" && $1 != "ls" && $1 != "purge" && $1 != "repo-add" \
        && $1 != "repo-rm" && $1 != "rm" && $1 != "sign" && $1 != "unsign" \
        && $1 != "update" && $1 != "version" ]]
    then
        error "crema $1: Unknown command. Run 'crema help' for usage."
        crema_exit 1
    fi
    # set CMD
    case $1 in
        --help | -h)
            CMD="help"
            ;;
        *)
            CMD=$1
            ;;
    esac
    shift

    # retrieve arguments
    while (( "$#" ))
    do
        case $1 in
            -f:aur | --from:aur | -f:local | --from:local)
                SOURCE=${1#-*:}
                shift
                ;;
            -f:* | --from:*)
                error "\'${1#-*:}\' is not a valid source"
                crema_exit 1
                ;;
            --nochroot | -n)
                MAKEARGS=("--" "-c")
                shift
                ;;
            --path | -p)
                # check if a path was given
                if [[ -z ${2+x} || $2 = "" ]]
                then
                    error "Path to a repository required"
                    crema_exit 1
                fi
                REPODIR=$2
                shift 2
                ;;
            --repo | -r)
                # check if repository has been specified
                if [[ -z ${2+x} || $2 = "" ]]
                then
                    error "Repository required"
                    crema_exit 1
                fi
                REPO=$2
                shift 2
                ;;
            --sign | -s)
                if [[ -z ${GPGKEY+x} || $GPGKEY = "" ]]
                then
                    error "GPGKEY must be set"
                    crema_exit 1
                fi
                SIGNARGS_AUR+=("-s")
                SIGNARGS_REPO+=("-s" "-k" "$GPGKEY")
                shift
                ;;
            -*)    
                error "\'$1\' is not a valid flag"
                crema_exit 1
                ;;

            *)
                break
                ;;
        esac
    done

    # collect all remaining arguments
    REMARGS=($@)
}

# read_db --- reads database of repo $REPO
# usage: read_db
read_db () {
    local -a pkgs
    local pkg

    # nothing to do if no package db exists
    if [[ ! -e "${TEMPREPODIR}/${REPO}.db.tar.xz" ]]
    then
        return
    fi    

    mapfile -t pkgs < <( tar -tf "${TEMPREPODIR}/${REPO}.db.tar.xz")

    for pkg in "${pkgs[@]}"
    do
        if [[ $pkg =~ .+/$ ]]
        then
            echo "$REPO ${pkg%/}"
        fi    
    done
}    

# read_repodir --- reads repodir from the file $CFGFILE (i.e. '.config/crema.cfg')
# usage: read_repodir
read_repodir () {
    # check if the config file exists
    if [[ ! -e $CFGFILE ]]
    then
        error "'$REPO' not found in config. Use \'crema repo-add\' to add the repository."
        crema_exit 1
    fi
    REPODIR=$(sed -n -e "/${REPO}|/s/^${REPO}|\(.*\)/\1/p" < "$CFGFILE")
    # check if path to repository could be determined
    if [[ -z ${REPODIR+x} || $REPODIR = "" ]]
    then
        error "'$REPO' found in config. Use \'crema repo-add\' to add the repository."
        crema_exit 1
    fi
}

# set_signargs --- sets SIGNARGS_* signargs even if --sign wasn't set on
# command line, but if the repository database was signed, SIGNARGS_* must be
# set
# usage: set_signargs
set_signargs () {
    if [[ -e "${TEMPREPODIR}/$REPO.db.tar.xz.sig" ]]
    then
        if [[ -z ${GPGKEY+x} || $GPGKEY = "" ]]
        then
            error "Repository is signed, but GPGKEY is not set"
            crema_exit 1
        fi
        SIGNARGS_AUR+=("-s")
        SIGNARGS_REPO+=("-s" "-k" "$GPGKEY")
    fi
}

# upload_repo --- upload to custom repository (incl. package files) and delete
# temporary directory
# usage: upload_repo
upload_repo () {
    msg "uploading to \'$REPODIR\' ..."
    # sync local to remote repository
    rsync -a --delete --no-perms "${TEMPREPODIR}/" "${REPODIR}"
}    

# verify_signature --- verifies gpg signature of a file
# usage: verify_signature <file>
verify_signature () {
    [[ ! -z ${1+x} ]] || return 0
    [[ -e "$1" ]] || return 0

    if [[ -e "$1.sig" ]]
    then
        gpg --verify "$1.sig" "$1"
        if (( $? ))
        then
            error "\'$1\' has bad signature"
            crema_exit 1
        fi    
    fi
}


################################################################################
# main program                                                                 #
################################################################################

# set message colors
colorize

# clean up potential leftovers from last run
cleanup_temp

# parse command line argumantes
parse_args $@

# execute sub commands
case $CMD in
    add)
        # repository must be given
        check_repo
        # source must be given
        if [[ -z ${SOURCE+x} || $SOURCE = "" ]]
        then
            error "Command requires source"
            crema_exit 1
        fi

        # if packages from AUR shall be added, the packages must come from
        # command line
        if [[ $SOURCE = "aur" && ${#REMARGS[@]} = 0 ]]
        then
            error "No package to add"
            crema_exit 1
        fi
        # get path to repository
        read_repodir
        # download local repo incl. packages files
        download_repo all
        set_signargs
        # if there's no database yet: create it
        if [[ ! -e "${TEMPREPODIR}/${REPO}.db.tar.xz" ]]
        then
            echo "empty"
            repo-add -n -R "${TEMPREPODIR}/${REPO}.db.tar.xz"
            upload_repo
        fi
        # fetch packages from AUR
        case $SOURCE in
            aur)
                mkdir -p $PKGDIR
                cd "$PKGDIR"
                for pkg in "${REMARGS[@]}"
                do
                    # check if $pkg exists in AUR
                    aur search $pkg >/dev/null
                    if [[ $? -gt 0 ]]
                    then 
                        error "Package \'$pkg\' not found in AUR"
                        continue
                    fi
                    # clone package
                    aur fetch $pkg
                done
                ls > "$TEMPFILE"
                ;;
            local)    
                # build queue for aur build: if list of PKGBUILD paths is empty ...
                if [[ ${#REMARGS[@]} = 0 ]]
                then
                    if [[ ! -e "./PKGBUILD" ]]
                    then
                        error "PKGBUILD doesn't exist"
                        crema_exit 1
                    fi    
                    # ... add current path to queue
                    echo "." > "$TEMPFILE"
                else
                    # otherwise: add all remaining arguments to the queue
                    for dir in ${REMARGS[@]}
                    do
                        # check if $dir is a directory
                        if [[ ! -d "$dir" ]]
                        then
                            error "\'$dir\' is not a directory"
                            continue
                        fi
                        # check if $dir contains a PKGBUILD file
                        if [[ ! -e "$dir/PKGBUILD" ]]
                        then
                            error "PKGBUILD doesn't exist in \'$dir\'"
                            continue
                        fi
                        # add $dir to build queue (prior to that: convert it 
                        # into a relative path if necessary)
                        if [[ "$dir" = /* ]]
                        then
                            realpath --relative-to=. "$dir" >> "$TEMPFILE"
                        else
                            echo "$dir" >> "$TEMPFILE"
                        fi
                    done
                fi
                ;;
        esac
        # build and add packages to local repository
        if [[ -s "$TEMPFILE" ]]
        then
            aur build -d "$REPO" -a "$TEMPFILE" --root="$TEMPREPODIR" -N \
                ${SIGNARGS_AUR[@]} ${MAKEARGS[@]} || true
        fi
        [[ $SOURCE != "aur" ]] || cd -
        cleanup_repo
        # upload adjusted local repo incl. package files
        upload_repo
        ;;

    cleanup)
        # if repo has been specified: ...
        if [[ -n $REPO ]]
        then
            repo=$REPO
        fi

        while IFS='|' read -r REPO REPODIR
        do
            if [[ ! -z ${repo+x} && $repo != $REPO ]]
            then
                continue
            fi
            # download local repo incl. packages files
            download_repo all
            set_signargs

            cleanup_repo

            # upload adjusted local repo incl. package files
            upload_repo
        done < "$CFGFILE"
        ;;

    chroot-add-key)
        if [[ -z ${2+x} ]]
        then
            error "key is required"
            crema_exit 1
        fi    
        sudo arch-chroot "$CHROOTDIR"/root pacman-key -r $2
        if [[ $? == 0 ]]
        then
            msg "key $2 added to chroot environment"
        else
            error "key $2 could not be added to chroot environment"
        fi    
        ;;

    chroot-rm)
        sudo rm -rfd "$CHROOTDIR"
        msg "Chroot environment \'$CHROOTDIR\' removed"
        ;;

    env)
        [[ -e $CFGFILE ]] || crema_exit 0

        # initialize local variables
        declare -i len=10      # set max length to the length of "REPOSITORY"
        declare -i counter=0   # count number of entries
        declare -a repos=()    # repository array
        declare -a repodirs=() # array of repo paths
        
        # determine length of repo column
        while IFS='|' read repo repodir
        do
            if [[ ${#repo} = 0 ]]
            then
                continue
            fi
            if [[ $len -lt ${#repo} ]]
            then
                len=${#repo}
            fi
            repos+=($repo)
            repodirs+=($repodir)
            counter+=1
        done < $CFGFILE
        # nothing to do if conf file doesn't contain repo data
        [[ $counter -gt 0 ]] ||  crema_exit 0
        # print headline
        printf "%-${len}s %s\n" "REPOSITORY" "PATH"
        # print content
        for ((i=0; i<$counter; i++));
        do
            printf "%-${len}s %s\n" ${repos[i]} ${repodirs[i]}
        done
        ;;    

    help)
        print_help ${REMARGS[@]}
        ;;

    ls)
        # if repo has been specified: ...
        if [[ -n $REPO ]]
        then
            repo=$REPO
        fi

        while IFS='|' read -r REPO REPODIR
        do
            if [[ ! -z ${repo+x} && $repo != $REPO ]]
            then
                continue
            fi
                        
            # download local repo incl. packages files
            download_repo db
            # list packages
            read_db
        done < $CFGFILE
        ;;
    purge)    
        # repository must be given
        check_repo
        read -p "Do you really want to delete all packages from repository '$REPO' (y/N)? " c
        if [[ $c == "y" ]]
        then
            # get path to repository
            read_repodir
            # download local repo incl. packages files
            download_repo all
            rm -rdf "$TEMPREPODIR"/*
            # upload adjusted local repo incl. package files
            upload_repo
        fi    
        ;;

    repo-add)
        # repository must be given
        check_repo
        # path to repository must be given
        if [[ -z ${REPODIR+x} || $REPODIR = "" ]]
        then
            error "Path to repository required"
            crema_exit 1
        fi
        # make sure that config file exists
        [[ -e "$CFGFILE" ]] || touch "$CFGFILE"
        # check if REPO is already contained in config file
        repodir=$(sed -n -e "/${REPO}|/s/^${REPO}|\(.*\)/\1/p" < "$CFGFILE")
        if [[ ! -z ${repodir+x} && $repodir != "" ]]
        then
            if [[ $repodir = $REPODIR ]]
            then
                warning "cream knows \'$REPO\' already: Nothing to do."
                crema_exit 0
            else
                error "cream knows \'$REPO\' already, but with path \'$repodir\'"
                crema_exit 1
            fi
        fi
        echo "$REPO|$REPODIR" >> $CFGFILE
        msg "\'$REPO\' added to configuration"
        ;;

    repo-rm)
        # repository must be given
        check_repo
        # nothing to do if config doesn't exist
        if [[ ! -e "$CFGFILE" ]]
        then
            warning "Config file doesn't exist: Nothing to do."
            crema_exit 0
        fi
        # nothing to do if config file doesn't contain REPO
        if [[ -z $( grep -F "${REPO}|" "$CFGFILE" 2> /dev/null ) ]]
        then
            warning "Config file doesn't contain \'$REPO\': Nothing to do"
            crema_exit 0
        fi
        # remove repo from config file
        sed -i /${REPO}\|/d "$CFGFILE"
        ;;

    rm)   
        # any package to remove?
        if [[ $# = 0 ]]
        then
            error "No package to remove"
            crema_exit 1
        fi
        # repository must be given
        check_repo
        read_repodir
        # download local repo incl. packages files
        download_repo all
        set_signargs
        # removal only makes sense if there's already a database
        if [[ ! -e "${TEMPREPODIR}/${REPO}.db.tar.xz" ]]
        then
            error "No repository database found"
            crema_exit 1
        fi    
        # remove packages from local repo db and remove package files
        cd "$TEMPREPODIR"
        repo-remove ${SIGNARGS_REPO[@]} "${REPO}.db.tar.xz" "${REMARGS[@]}"
        for pkg in "${REMARGS[@]}"
        do
            rm -f "$pkg"*pkg.tar.xz
            rm -f "$pkg"*pkg.tar.xz.sig
        done
        cd -
        # upload adjusted local repo incl. package files
        upload_repo
        ;;

    sign)
        # GPGKEY must be set
        if [[ -z ${GPGKEY+x} || $GPGKEY = "" ]]
        then
            error "GPGKEY is not set"
            crema_exit 1
        fi
        # repository must be specified
        if [[ -z ${REPO+x} || $REPO = "" ]]
        then
            error "Repository needed"
            crema_exit 1
        fi
        read_repodir
        # download local repo incl. packages files
        download_repo all
        for file in "$TEMPREPODIR"/*
        do
            # symbolic links are handled separately
            [[ -L "$file" ]] && continue
            # nothing to do for signature files
            [[ "$file" = *.sig ]] && continue
            # nothing to do for old files
            [[ "$file" = *.old ]] && continue
            # nothing to do if a signature file for $file already exists
            [[ -e "$file.sig" ]] && continue
            # create signature file
            gpg -u $GPGKEY --output "$file.sig" --detach-sign "$file"
            msg "Signed: ${file##/*/}"
        done
        # handle symbolic links
        cd "$TEMPREPODIR"
        [[ -e "$REPO.db.sig" ]] || ln -s "$REPO.db.tar.xz.sig" "$REPO.db.sig"
        [[ -e "$REPO.file.sig" ]] || ln -s "$REPO.files.tar.xz.sig" "$REPO.files.sig"
        cd -
        # upload adjusted local repo incl. package files
        upload_repo
        ;;

    unsign)
        # repository must be specified
        if [[ -z ${REPO+x} || $REPO = "" ]]
        then
            error "Repository required"
            crema_exit 1
        fi
        read_repodir
        # download local repo incl. packages files
        download_repo all
        # check if repo is already signed
        if [[ ! -e "$TEMPREPODIR/$REPO.db.tar.xz.sig" ]]
        then
            msg "\'$REPO\' is not signed: Nothing to do"
            crema_exit 0
        fi
        # remove signature files
        rm -f "$TEMPREPODIR"/*.sig
        # upload adjusted local repo incl. package files
        upload_repo
        ;;

    update)
        # if repo has been specified: ...
        if [[ -n $REPO ]]
        then
            repo=$REPO
        fi

        while IFS='|' read -r REPO REPODIR
        do
            if [[ ! -z ${repo+x} && $repo != $REPO ]]
            then
                continue
            fi
            
            # download local repo incl. packages files
            download_repo all
            set_signargs
            # update only makes sense if there's already a database
            if [[ -e "${TEMPREPODIR}/${REPO}.db.tar.xz" ]]
            then
                # update outdated packages
                cd "$TEMPREPODIR"
                aur sync -d "$REPO" --root="$TEMPREPODIR" -u -n \
                    ${SIGNARGS_AUR[@]} ${MAKEARGS[@]} || true
                cd -
                cleanup_repo
                # upload adjusted local repo incl. package files
                upload_repo
            fi
        done < "$CFGFILE"
        ;;

    version)
        echo "crema version $VERSION"
        ;;    

    *)
        error -e "Unknown command\n"
        print_help
        crema_exit 1
        ;;
esac

crema_exit 0

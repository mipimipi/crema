#!/bin/bash
#
# Copyright (C) 2019 Michael Picht
#
# This file is part of crema (Custom Repository Management).
#
# crema is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# crema is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with crema. If not, see <http://www.gnu.org/licenses/>.
#
# This script is based on the work of Michael Daffin on managing
# Arch Linux install. See: https://github.com/mdaffin/arch-pkgs

################################################################################
# global declarations
################################################################################

set -uo pipefail
set -o nounset
trap 's=$?; echo "$0: Error on line "$LINENO": $BASH_COMMAND"; exit $s' ERR

declare -r VERSION=1.2
declare -r TEMPDIR=${XDG_CACHE_HOME:-"$HOME"/.tmp}/local-repo
declare -r CFGFILE=${XDG_CONFIG_HOME:-"$HOME"/.config}/crema.conf
declare REPO=""
declare SIGN=false
declare REPODIR=""
declare CMD=""

################################################################################
# functions
################################################################################

# print_help --- print help text
# usage: print_help
print_help () {
    cat <<EOF
crema $VERSION
Copyright (C) 2019 Michael Picht <https://github.com/mipimipi/crema>

crema helps managing custom repositories. These can contain packages from AUR or other, user-defined packages. With crema, packages can be added, removed, built, updated etc.

Usage: crema <command> [<arguments>] 

The commands are:
  add       Add AUR packages to the custom repository
  build     Build packages from a PKGBUILD file and add them to the custom repository  
  env       List the repositories and their directories
  help      Help about any command
  ls        List all packages of the custom repository
  rm        Remove AUR packages from the custom repository
  update    Update all outdated AUR packages in the custom repository  
  version   Display version of crema

Use "crema help <command>" for more information about any command.
EOF
}

# print_help_add --- print help text for add command
# usage: print_help_add
print_help_add () {
    cat <<EOF
Usage: crema add (--repo | -r) <repository> <package> [<packages>]

Add AUR packages incl. the corresponding package tarballs to the custom repository.
EOF
}

# print_help_build --- print help text for build command
# usage: print_help_build
print_help_build () {
    cat <<EOF
Usage: crema build (--repo | -r) <repository> [(--sign | -s)] [<paths to PKGBUILD>]

Build packages from a PKGBUILD file and add them and the corresponding packages tarballs to the custom repository. If the command is called without a path, it looks for PKGBUILD in the current path.
EOF
}

# print_help_env --- print help text for env command
# usage: print_help_env
print_help_env () {
    cat <<EOF
Usage: crema env

List the repositories that crema knows and their paths.
EOF
}

# print_help_ls --- print help text for ls command
# usage: print_help_ls
print_help_rm () {
    cat <<EOF
Usage: crema ls <repository>

List all packages of the custom repository
EOF
}
# print_help_rm --- print help text for rm command
# usage: print_help_rm
print_help_rm () {
    cat <<EOF
Usage: crema rm (--repo | -r) <repository> <package> [<packages>]

Remove packages and the corresponding package tarballs from the custom repository
EOF
}

# print_help_update --- print help text for update command
# usage: print_help_update
print_help_update () {
    cat <<EOF
Usage: crema update (--repo | -r) <repository>

Update all outdated AUR packages in the custom repository.
EOF
}

# read_repodir --- reads repodir from the file $CFGFILE (i.e. '.config/crema.cfg')
# usage: read_repodir
read_repodir () {
    # check if the config file exists
    if [[ ! -e $CFGFILE ]]
    then
        echo "a repository path for '$REPO'needs to be maintained in $CFGFILE"
        exit 1
    fi
# TODO
    # check if path to repository could be determined
    if [[ -z ${REPODIR+x} ]] || [[ $REPODIR = "" ]]
    then
        echo "a repository path for '$REPO'needs to be maintained in $CFGFILE"
        exit 1
    fi
}

# exec_makepkg --- execute makepkg
# usage: exec_makepkg <path-to-PKGBUILD>
exec_makepkg () {
    # save current directory
    ORIGDIR=$PWD
    # cd into package directory
    if [ ! -z ${1+x} ]
    then
        cd "$1"
    fi
    # download local repo incl. packages files
    download_repo
    # get packages that are going to be built
    IFS=$'\n' PKGS_ORIG=($(makepkg --packagelist))
    for ((i=0; i<${#PKGS_ORIG[@]}; i++));
    do
        PKGS[i]=${PKGS_ORIG[i]##/*/}
    done
    # build packages and remove temporary files
    makepkg -c
    # mv package files to temp dir
    mv -f *.pkg.tar.xz "$TEMPDIR"
    # add new packages / package versions to custom repository
    cd "$TEMPDIR"
    for pkg in ${PKGS[@]}
    do
        repo-add -n -R "${REPO}.db.tar.xz" "$pkg"
    done    
    cd -
    # upload adjusted local repo incl. package files
    upload_repo
    # cd back to original directory
    cd "$ORIGDIR"
}

# download_repo --- download custom repository (incl. package files) to
# temporary directory
# usage: download_repo
download_repo () {
    # create temporary repository directory
    mkdir -p "$TEMPDIR"
    # sync remote to custom repository
    rsync -a "${REPODIR}/" "${TEMPDIR}"     
}     

# upload_repo --- upload to custom repository (incl. package files) and delete
# temporary directory
# usage: upload_repo
upload_repo () {
    # sync local to remote repository
    rsync -a --delete --no-perms "${TEMPDIR}/" "${REPODIR}"
    # remove temporary directory since it's no longer needed
    rm -rd "${TEMPDIR}"
}    

################################################################################
# main program
################################################################################

# crema needs a command
if [[ $# = 0 ]]
then
    echo "crema expects a command"
    exit 1
fi

# check command
if [[ $1 != "add" && $1 != "build" && $1 != "env" && $1 != "help" && $1 != "ls" && 1 != "rm" && $1 != "update" ]]
then
   echo "'$1' is no valid command"
   exit 1
fi
CMD=$1
shift

# retrieve arguments
while [ $# -gt 0 ]
do
    case $1 in
        --repo | -r)
            # check if repository has been specified
            if [[ -z ${2+x} ]] || [[ $2 = "" ]]
            then
                echo "command needs a repository"
                exit 1
            fi
            REPO=$2
            shift 2
            ;;
        --sign | -s)
            # check if gpg key is set
            if [[ -z ${GPGKEY+x} ]] || [[ $GPGKEY = "" ]]
            then
                echo "gpg key needs to be set in variable GPGKEY"
                exit 1
            fi
            SIGN=true
            shift
            ;;
        *)
            break
            ;;
    esac
done

case $CMD in
    add)
        # any package to add?
        if [[ $# = 0 ]]
        then
            echo "no package to add"
            exit 0
        fi
        # get path to repository
        read_repodir
        # download local repo incl. packages files
        download_repo
        # add packages
        aur sync -d "$REPO" --root="$TEMPDIR" -n "$@" || true
        # upload adjusted local repo incl. package files
        upload_repo
        exit 0
        ;;

    build)
        read_repodir
        exec_makepkg $1
        ;;

    env)
        [[ -e $CFGFILE ]] || exit 0

        # initialize local variables
        declare -i len=10      # set max length to the length of "REPOSITORY"
        declare -i counter=0   # count number of entries
        declare -a repos=()    # repository array
        declare -a repodirs=() # array of repo paths
        
        while IFS='|' read repo repodir
        do
            if [[ $len -lt ${#repo} ]]
            then
                len=${#repo}
            fi
            repos+=($repo)
            repodirs+=($repodir)
            counter+=1
        done < $CFGFILE
        # nothing to do if conf file doesn't contain repo data
        [[ $counter -gt 0 ]] ||  exit 0
        # print headline
        printf "%-${len}s %s\n" "REPOSITORY" "PATH"
        # print content
        for ((i=0; i<$counter; i++));
        do
            printf "%-${len}s %s\n" ${repos[i]} ${repodirs[i]}
        done
        ;;    

    help)
        if [[ $# = 0 ]]
        then
            print_help
            exit 0
        fi
        if [[ $1 != "add" && $1 != "build" && $1 != "env" && $$1 != "ls" && 1 != "rm" && $1 != "update" ]]
        then
            echo "no help available for '$1'"
            exit 1
        fi
        print_help_$1
        ;;

    ls)
        shift
        pacman -Sl ${REPO}
        ;;

    rm)    
        # any package to remove?
        if [[ $# = 0 ]]
        then
            echo "no package to remove"
            exit 0
        fi
        read_repodir
        # download local repo incl. packages files
        download_repo
        # remove packages from local repo db and remove package files
        cd "$TEMPDIR"
        repo-remove "${REPO}.db.tar.xz" "$@"
        for pkg in $@
        do
            rm -f "$pkg"*pkg.tar.xz
        done
        cd -
        # upload adjusted local repo incl. package files
        upload_repo
        ;;

    update)
        read_repodir
        # download local repo incl. packages files
        download_repo
        # update outdated packages
        cd "$TEMPDIR"
        aur sync -d "$REPO" --root="$TEMPDIR" -u -n || true
        cd -
        # upload adjusted local repo incl. package files
        upload_repo
        ;;

    version)
        echo "crema version $VERSION"
        ;;    

    *)
        echo -e "unknown command\n"
        print_help
        exit 1
        ;;
esac
